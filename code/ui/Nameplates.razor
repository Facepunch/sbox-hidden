@using System;
@using Sandbox;
@using Sandbox.UI;
@using Facepunch.Hidden;
@using System.Collections.Generic;
@using System.Linq;

@namespace Facepunch.Hidden
@attribute [StyleSheet( "/ui/Nameplates.scss" )]
@inherits Panel

@code
{
    private readonly Dictionary<HiddenPlayer, Nameplate> ActiveNameplates = new();

    public float MaxDrawDistance = 400;
    public int MaxNameplates = 10;

    public override void Tick()
    {
        base.Tick();

        var deleteList = new List<HiddenPlayer>();
        var count = 0;

        deleteList.AddRange( ActiveNameplates.Keys );

        var players = Entity.All.OfType<HiddenPlayer>().OrderBy( x => Vector3.DistanceBetween( x.EyePosition, Camera.Position ) );

        foreach ( var v in players )
        {
            if ( UpdateNameplate( v ) )
            {
                deleteList.Remove( v );
                count++;
            }

            if ( count >= MaxNameplates )
                break;
        }

        foreach ( var player in deleteList )
        {
            ActiveNameplates[player].Delete();
            ActiveNameplates.Remove( player );
        }
    }

    public Nameplate CreateNameplate( HiddenPlayer player )
    {
        var tag = new Nameplate( player )
		{
			Parent = this
		};

        return tag;
    }

    public bool UpdateNameplate( HiddenPlayer player )
    {
        if ( player.IsLocalPawn || !player.HasTeam || player.Team.HideNameplate )
            return false;

        if ( player.LifeState != LifeState.Alive )
            return false;

        var labelPos = player.EyePosition + player.Rotation.Up * 10f;

        float dist = labelPos.Distance( Camera.Position );

        if ( dist > MaxDrawDistance )
            return false;

        var localPlayer = HiddenPlayer.Me;

		// If we're not spectating only show nameplates of players we can see.
		if ( !localPlayer.IsSpectator )
		{
			var lookDir = (labelPos - Camera.Position).Normal;

			if ( Camera.Rotation.Forward.Dot( lookDir ) < 0.5 )
				return false;

			var trace = Trace.Ray( localPlayer.EyePosition, player.EyePosition)
				.Ignore( localPlayer )
				.Run();

			if ( trace.Entity != player )
				return false;
		}

		var alpha = dist.LerpInverse( MaxDrawDistance, MaxDrawDistance * 0.1f, true );
		var objectSize = 0.2f / dist / (2.0f * MathF.Tan( (Camera.FieldOfView / 2.0f).DegreeToRadian() )) * 1500.0f;

		objectSize = objectSize.Clamp( 0.05f, 1.0f );

		if ( !ActiveNameplates.TryGetValue( player, out var tag ) )
		{
			tag = CreateNameplate( player );
			ActiveNameplates[player] = tag;
		}

		var screenPos = labelPos.ToScreen();

		tag.Style.Left = Length.Fraction( screenPos.x );
		tag.Style.Top = Length.Fraction( screenPos.y );
		tag.Style.Opacity = alpha;

		var transform = new PanelTransform();
		transform.AddTranslateY( Length.Fraction( -1.0f ) );
		transform.AddTranslateX( Length.Fraction( -0.5f ) );
		transform.AddScale( objectSize );

		tag.Style.Transform = transform;
		tag.Style.Dirty();

		return true;
	}
}
